<div>
  <p>Ever found yourself wanting to put an application behind a login form, but dreading writing all that code to deal with OAuth 2.0 or passwords? In this tutorial, I’ll show you how to use the nginx <code>auth_request</code> module to protect any application running behind your nginx server with OAuth 2.0, without writing any code! Vouch, a microservice written in Go, handles the OAuth dance to any number of different auth providers so you don’t have to.</p>

<p><strong>Tip:</strong> If you want to add login (and URL based authorization) to more apps via a UI, integrate with more complex apps like Oracle or SAP, or replace legacy Single Sign-On on-prem, check the <a href="https://www.okta.com/products/access-gateway/" rel="noopener noreferrer">Okta Access Gateway</a>.</p>

<h2>Why Authenticate at the Web Server?</h2>

<p>Imagine you use nginx to run a small private wiki for your team. At first, you probably start out with adding a wiki user account for each person. It’s not too bad, adding new accounts for new hires, and removing them when they leave.</p>

<p>A few months later, as your team and company start growing, you add some server monitoring software, and you want to put that behind a login so only your company can view it. Since it’s not very sophisticated software, the easiest way to do that is to create a single password for everyone in an <code>.htpasswd</code> file, and share that user with the office.</p>

<p>Another month goes by, and you add a continuous integration system, and that comes with GitHub authentication as an option, which seems reasonable since most of your team has GitHub accounts already.</p>

<p>At this point, when someone new joins, you have to create a wiki account for them, add them to the GitHub organization, and give them the shared password for the other system. When someone leaves, you can delete their wiki account and remove them from GitHub, but let’s face it, you probably won’t change the shared password for a while since it’s annoying having to distribute that to everyone again.</p>

<p>Surely there must be a better way to integrate all these systems to use a common shared login system! The problem is the wiki is written in PHP, the server monitoring system just ends up publishing a folder of static HTML, and the CI system is written in Ruby which only one person on your team feels comfortable writing.</p>

<p>If the web server could handle authenticating users, then each backend system wouldn’t need to worry about it, since the only requests that could make it through would already be authenticated!</p>

<h2>Using the nginx auth_request Module</h2>

<p>Enter the nginx <code>auth_request</code> module.</p>

<p>This module is shipped with nginx, but requires enabling when you compile nginx. When you download the nginx source and compile, just include the <code>--with-http_auth_request_module</code> flag along with any others that you use.</p>

<p>The <code>auth_request</code> module sits between the internet and your backend server that nginx passes requests onto, and any time a request comes in, it first forwards the request to a separate server to check whether the user is authenticated, and uses the HTTP response to decide whether to allow the request to continue to the backend.</p>

<p><img alt="Flowchart illustrating the nginx auth_request module" width="400"></p>

<p>This diagram illustrates a request that comes in for the server name <code>stats.avocado.lol</code>. First, nginx fires off a sub-request to <code>login.avocado.lol</code> (1), and if the response (2) to that request returns HTTP 200, it then continues forwarding the request on to the backend <code>stats.avocado.lol.</code></p>

<h2>Choosing an Auth Proxy</h2>

<p>Since the nginx <code>auth_request</code> module has no concept of users or how to authenticate anyone, we need something else in the mix that can actually handle logging users in. In the diagram above, this is illustrated by the server name <code>login.avocado.lol</code>.</p>

<p>This server needs to handle an HTTP request and return HTTP 200 or 401 depending on whether the user is logged in. If the user is not logged in, it needs to know how to get them to log in and set a session cookie.</p>

<p>To accomplish this, we’ll use the open source project “<a href="https://github.com/vouch/vouch-proxy" rel="noopener noreferrer">Vouch</a>”. Vouch is written in Go, so it’s super easy to deploy. Everything can be configured via a single YAML file. Vouch can be configured to authenticate users via a variety of OAuth and OpenID Connect backends such as GitHub, Google, Okta or any other custom servers.</p>

<p>We’ll come back to configuring Vouch in a few minutes, but for now, let’s continue on to set up your protected server in nginx.</p>

<h2>Configure Your Protected nginx Host</h2>

<p>Starting with a typical nginx server block, you just need to add a couple lines to enable the <code>auth_request</code> module. Here is an example server block that should look similar to your own config. This example just serves a folder of static HTML files, but the same idea applies whether you’re passing the request on to a fastcgi backend or using <code>proxy_pass</code>.</p>

<div><div><pre><code><span>server</span> <span>{</span>
  <span>listen</span> <span>443</span> <span>ssl</span> <span>http2</span><span>;</span>
  <span>server_name</span> <span>stats.avocado.lol</span><span>;</span>

  <span>ssl_certificate</span> <span>/etc/letsencrypt/live/avocado.lol/fullchain.pem</span><span>;</span>
  <span>ssl_certificate_key</span> <span>/etc/letsencrypt/live/avocado.lol/privkey.pem</span><span>;</span>

  <span>root</span> <span>/web/sites/stats.avocado.lol</span><span>;</span>

  <span>index</span> <span>index.html</span><span>;</span>
<span>}</span>
</code></pre></div></div>

<p>Add the following to your existing <code>server</code> block:</p>

<div><div><pre><code><span># Any request to this server will first be sent to this URL</span>
<span>auth_request</span> <span>/vouch-validate</span><span>;</span>

<span>location</span> <span>=</span> <span>/vouch-validate</span> <span>{</span>
  <span># This address is where Vouch will be listening on</span>
  <span>proxy_pass</span> <span>http://127.0.0.1:9090/validate</span><span>;</span>
  <span>proxy_pass_request_body</span> <span>off</span><span>;</span> <span># no need to send the POST body</span>

  <span>proxy_set_header</span> <span>Content-Length</span> <span>""</span><span>;</span>
  <span>proxy_set_header</span> <span>X-Real-IP</span> <span>$remote_addr</span><span>;</span>
  <span>proxy_set_header</span> <span>X-Forwarded-For</span> <span>$proxy_add_x_forwarded_for</span><span>;</span>
  <span>proxy_set_header</span> <span>X-Forwarded-Proto</span> <span>$scheme</span><span>;</span>

  <span># these return values are passed to the @error401 call</span>
  <span>auth_request_set</span> <span>$auth_resp_jwt</span> <span>$upstream_http_x_vouch_jwt</span><span>;</span>
  <span>auth_request_set</span> <span>$auth_resp_err</span> <span>$upstream_http_x_vouch_err</span><span>;</span>
  <span>auth_request_set</span> <span>$auth_resp_failcount</span> <span>$upstream_http_x_vouch_failcount</span><span>;</span>
<span>}</span>

<span>error_page</span> <span>401</span> <span>=</span> <span>@error401</span><span>;</span>

<span># If the user is not logged in, redirect them to Vouch's login URL</span>
<span>location</span> <span>@error401</span> <span>{</span>
  <span>return</span> <span>302</span> <span>https://login.avocado.lol/login?url=https://</span><span>$http_host$request_uri</span><span>&amp;vouch-failcount=</span><span>$auth_resp_failcount</span><span>&amp;X-Vouch-Token=</span><span>$auth_resp_jwt</span><span>&amp;error=</span><span>$auth_resp_err</span><span>;</span>
<span>}</span>
</code></pre></div></div>

<p>Let’s look at what’s going on here. The first line, <code>auth_request /vouch-validate;</code> is what enables this flow. This tells the <code>auth_request</code> module to first send any request to this URL before deciding whether it’s allowed to continue to the backend server.</p>

<p>The block <code>location = /vouch-validate</code> captures that URL, and proxies it to the Vouch server that will be listening on port 9090. We don’t need to send the POST body to Vouch, since all we really care about is the cookie.</p>

<p>The line <code>error_page 401 = @error401;</code> tells nginx what to do if Vouch returns an HTTP 401 response, which is to pass it to the block defined by <code>location @error401</code>. That block will redirect the user’s browser to Vouch’s login URL which will kick off the flow to the real authentication backend.</p>

<h2>Configure a Server Block for Vouch</h2>

<p>Next, configure a new server block for Vouch so that it has a publicly accessible URL like <code>https://login.avocado.lol</code>. All this needs to do is proxy the request to the backend Vouch server.</p>

<div><div><pre><code><span>server</span> <span>{</span>
  <span>listen</span> <span>443</span> <span>ssl</span><span>;</span>
  <span>server_name</span> <span>login.avocado.lol</span><span>;</span>

  <span>ssl_certificate</span> <span>/etc/letsencrypt/live/login.avocado.lol/fullchain.pem</span><span>;</span>
  <span>ssl_certificate_key</span> <span>/etc/letsencrypt/live/login.avocado.lol/privkey.pem</span><span>;</span>

  <span># Proxy to your Vouch instance</span>
  <span>location</span> <span>/</span> <span>{</span>
    <span>proxy_set_header</span>  <span>Host</span>  <span>login.avocado.lol</span><span>;</span>
    <span>proxy_set_header</span>  <span>X-Forwarded-Proto</span> <span>https</span><span>;</span>
    <span>proxy_pass</span>        <span>http://127.0.0.1:9090</span><span>;</span>
  <span>}</span>
<span>}</span>
</code></pre></div></div>

<h2>Configure and Deploy Vouch</h2>

<p>You’ll need to download <a href="https://github.com/vouch/vouch-proxy" rel="noopener noreferrer">Vouch</a> and compile the Go binary for your platform. You can follow the instructions in the project’s README file.</p>

<p>Once you’ve got a binary, you’ll need to create the config file to define the way you want Vouch to authenticate users.</p>

<p>Copy <code>config/config.yml_example</code> to <code>config/config.yml</code> and read through the settings there. Most of the defaults will be fine, but you’ll want to create your own JWT secret string and replace the placeholder value of <code>your_random_string</code>.</p>

<p>The easiest way to configure Vouch is to have it allow any user that can authenticate at the OAuth server be allowed to access the backend. This works great if you’re using a private OAuth server like Okta to manage your users. Go ahead and set <code>allowAllUsers: true</code> to enable this behavior, and comment out the <code>domains:</code> chunk.</p>

<p>You’ll need to choose an OAuth 2.0 provider to use to actually authenticate users. In this example we’ll use Okta, since that’s the easiest way to have a full OAuth/OpenID Connect server and be able to manage all your user accounts from a single dashboard.</p>

<p>Before you begin, you’ll need a free Okta developer account. Install the <a href="https://cli.okta.com" rel="noopener noreferrer">Okta CLI</a> and run <code>okta register</code> to sign up for a new account. If you already have an account, run <code>okta login</code>.
Then, run <code>okta apps create</code>. Select the default app name, or change it as you see fit.
Choose <strong>Web</strong> and press <strong>Enter</strong>.</p>

<p>Select <strong>Other</strong>. 
    Then, change the Redirect URI to <code>https://login.avocado.lol/auth</code> and use <code>https://login.avocado.lol</code> for the Logout Redirect URI.</p>

<details>
  <summary>What does the Okta CLI do?</summary>
<p>The Okta CLI will create an OIDC Web App in your Okta Org. It will add the redirect URIs you specified and grant access to the Everyone group. You will see output like the following when it’s finished:</p>

<div><div><pre><code>Okta application configuration has been written to: /path/to/app/.okta.env
</code></pre></div></div>

<p>Run <code>cat .okta.env</code> (or <code>type .okta.env</code> on Windows) to see the issuer and credentials for your app.</p>

<div><div><pre><code><span>export </span><span>OKTA_OAUTH2_ISSUER</span><span>=</span><span>"https://dev-133337.okta.com/oauth2/default"</span>
<span>export </span><span>OKTA_OAUTH2_CLIENT_ID</span><span>=</span><span>"0oab8eb55Kb9jdMIr5d6"</span>
<span>export </span><span>OKTA_OAUTH2_CLIENT_SECRET</span><span>=</span><span>"NEVER-SHOW-SECRETS"</span>
</code></pre></div></div>

<p>Your Okta domain is the first part of your issuer, before <code>/oauth2/default</code>.</p>

<p><strong>NOTE</strong>: You can also use the Okta Admin Console to create your app. See <a href="https://developer.okta.com/docs/guides/sign-into-web-app/-/create-okta-application/" rel="noopener noreferrer">Create a Web App</a> for more information.</p>

</details>

<p>Now that you’ve registered the application in Okta, you’ll have a client ID and secret which you’ll need to include in the config file. You’ll also need to set the URLs for your authorization endpoint, token endpoint and userinfo endpoint. These will most likely look like the below using your Okta domain.</p>

<p><code>config.yml</code></p>

<div><div><pre><code><span>oauth</span><span>:</span>
  <span>provider</span><span>:</span> <span>oidc</span>
  <span>client_id</span><span>:</span> <span>{</span><span>yourClientID</span><span>}</span>
  <span>client_secret</span><span>:</span> <span>{</span><span>yourClientSecret</span><span>}</span>
  <span>auth_url</span><span>:</span> <span><span><span>https://{yourOktaDomain}</span></span>/oauth2/default/v1/authorize</span>
  <span>token_url</span><span>:</span> <span><span><span>https://{yourOktaDomain}</span></span>/oauth2/default/v1/token</span>
  <span>user_info_url</span><span>:</span> <span><span><span>https://{yourOktaDomain}</span></span>/oauth2/default/v1/userinfo</span>
  <span>scopes</span><span>:</span>
    <span>-</span> <span>openid</span>
    <span>-</span> <span>email</span>
  <span># Set the callback URL to the domain that Vouch is running on</span>
  <span>callback_url</span><span>:</span> <span>https://login.avocado.lol/auth</span>
</code></pre></div></div>

<p>Now you can run Vouch! It will listen on port 9090, which is where you’ve configured nginx to send the <code>auth_request</code> verifications as well as serve traffic from <code>login.avocado.lol</code>.</p>

<p>When you reload the nginx config, all requests to <code>stats.avocado.lol</code> will require that you log in via Okta first!</p>

<h2>Bonus: Who Logged In?</h2>

<p>If you’re putting a dynamic web app behind nginx and you care not only about <em>whether</em> someone was able to log in, but also <em>who they are</em>, there is one more trick we can use.</p>

<p>By default, Vouch will extract a user ID via OpenID Connect (or GitHub or Google if you’ve configured those as your auth providers), and will include that user ID in an HTTP header that gets passed back up to the main server.</p>

<p>In your main server block, just below the line <code>auth_request /vouch-validate;</code> which enables the <code>auth_request</code> module, add the following:</p>

<div><div><pre><code><span>auth_request_set</span> <span>$auth_user</span> <span>$upstream_http_x_vouch_user</span><span>;</span>
</code></pre></div></div>

<p>This will take the HTTP header that Vouch sets, <code>X-Vouch-User</code>, and assign it to the nginx variable <code>$auth_user</code>. Then, depending on whether you use fastcgi or proxy_pass, include one of the two lines below in your server block:</p>

<div><div><pre><code><span>fastcgi_param</span> <span>REMOTE_USER</span> <span>$auth_user</span><span>;</span>
<span>proxy_set_header</span> <span>Remote-User</span> <span>$auth_user</span><span>;</span>
</code></pre></div></div>

<p>These will set an HTTP header with the value of <code>$auth_user</code> that your backend server can read in order to know who logged in. For example, in PHP you can access this data using:</p>

<div><div><pre><code><span>&lt;?php</span>
<span>echo</span> <span>'Hello, '</span> <span>.</span> <span>$_SERVER</span><span>[</span><span>'REMOTE_USER'</span><span>]</span> <span>.</span> <span>'!'</span><span>;</span>
</code></pre></div></div>

<p>Now you can be sure that your internal app can only be accessed by authenticated users!</p>

<h2>Learn More About OAuth 2.0 and Secure User Management with Okta</h2>

<p>For more information and tutorials about OAuth 2.0, check out some of our other blog posts!</p>

<ul>
  <li><a rel="noopener noreferrer">Add Authentication to your PHP App in 5 Minutes</a></li>
  <li><a rel="noopener noreferrer">What is the OAuth 2.0 Authorization Code Grant Type?</a></li>
  <li><a rel="noopener noreferrer">What is the OAuth 2.0 Implicit Grant Type?</a></li>
</ul>

<p>As always, we’d love to hear from you about this post, or really anything else! Hit us up in the comments, or on Twitter <a href="https://twitter.com/OktaDev" rel="noopener noreferrer">@oktadev</a>!</p>

</div>
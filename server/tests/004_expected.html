<div><div><p>ChatGPT の勢いがすごいですね。きっと我々の仕事はなくなるのでしょう。<br>そんな中、空気を読まずに経路探索のアルゴリズムについて語ります。</p>
<p>この記事は <a href="https://github.com/msakuta/swarm-rs" rel="noopener noreferrer">swarm-rs</a> というゲーム実装のノートの一部 (<a href="https://github.com/msakuta/swarm-rs/wiki" rel="noopener noreferrer">こちら</a>) を翻訳し、少し肉付けしたものです。</p>
<p>まず前提ですが、経路探索するのは二次元の占有グリッド(Occupancy grid)の中です。<br>地形情報がバイナリイメージとして与えられていると考えても良いです。</p>
<p>経路探索のアルゴリズムとしては、ダイクストラ法とA*が有名ですが、これらについては良い教材が腐るほどあるので触れません。<br>ただ、どちらも探索空間をグラフとして表現することを前提とします。<br>占有グリッドをそのまま探索空間とすると、ゴールに至るまでのピクセルのほとんどを評価する必要があるので、探索計算が非常に長くなる傾向があります。<br>ここでは、バイナリイメージで与えられた探索空間をいかに探索に適した形に軽量化するかを考えます。</p>
<h2></h2><h1>
 トライアンギュレーション</h1>
<p>ゲームの世界ではAIの経路探索に使うデータ構造をナビゲーションメッシュなどと呼んだりします。<br>これはポリゴンの集まりで表現された空間の分割です。<br>このような分割に使われるアルゴリズムの一つがドロネー三角形分割です。<br>トライアンギュレーションとも呼ばれます。</p>
<p>探索空間が非常に小さくなり、探索を高速化することができますが、事前にドロネー三角形分割を実施しておく必要があるので、動的に変化する環境に適応するのは得意ではありません。</p>
<p><img src="https://user-images.githubusercontent.com/2798715/208233706-0ff9f0ed-acaa-46c0-87db-ccc774f166f0.gif" alt="Swarm-rs 2022-12-17 17-35-58_edit"></p>
<p>ドロネー三角形分割の利点は、占有グリッドの輪郭の複雑度に応じて動的にナビゲーションメッシュの細かさが変わることです。このことで、シンプルな形状には疎な三角形を使い、複雑な形状には密な三角形を使うことができ、資源の最適化ができます。<br>ピクセル単位のギザギザはRDPなどのアルゴリズムで単純化しておいた方が疎な三角形分割になります。</p>
<p><img src="https://user-images.githubusercontent.com/2798715/211263110-d20760ab-ea4b-4e6c-8839-4f95dcdb0575.png" alt="image"></p>
<p>しかし、ドロネー三角形分割は計算コストが高く、毎フレーム実行することはできません。<br>変化する環境に適応する、特に障害物回避には使えません。</p>
<p>具体的な構築方法については、結局次に述べる四分木メッシュをメインに使うことにしたので詳しくは述べませんが、おおむね次のようなステップになります。</p>
<ol>
<li>占有グリッドをバイナリイメージとして用意する。(上の図では Perlin noise を使っています)</li>
<li>Marching Squares アルゴリズムで境界のピクセルを抽出する</li>
<li>RDP アルゴリズムで単純化する</li>
<li>ドロネー三角形分割を実施する (delaunator という crate を使っています)</li>
<li>隣り合う三角形の距離に応じて探索コストを定義する</li>
</ol>
<h2></h2><h1>
 四分木メッシュ</h1>
<p>もう一つの方法は、四分木でナビゲーションメッシュを構築することです。<br>(<a href="https://www.researchgate.net/publication/235443232_Using_Quadtrees_for_Realtime_Pathfinding_in_Indoor_Environments" rel="noopener noreferrer">こちらの論文</a>がベースになっています)。<br>四分木の利点は、本質的に局所的であることで、構築するのに隣のセルをチェックする必要がありません。<br>このため、占有グリッドに変化があっても、それの再計算が局所的で済むという特徴があります。</p>
<p>また、ドロネー三角形分割では境界を単純化しておかないと十分に疎なメッシュになりませんでしたが、四分木ではその必要はないのも良いところです。</p>
<p>四分木の欠点は、トライアンギュレーションに比べるとノードの数が多く、メモリ使用量と探索コストの軽量化という点では敵わないところです。</p>
<p><img src="https://user-images.githubusercontent.com/2798715/211260262-bbbc210b-311e-4422-bdb7-62523e781e79.png" alt="image"></p>
<p>とは言え、それなりに疎な探索グラフは構築できます。</p>
<p><img src="https://user-images.githubusercontent.com/2798715/211263470-2dde8001-7cd5-4450-98f6-a821bf75f7e5.png" alt="image"></p>
<p>四分木メッシュの構築方法は非常にシンプルです。<br>下記のような再帰的アルゴリズムで実現できます。</p>
<ol>
<li>最上位のノード(マップ全てのピクセルを含む)をチェック対象のセルとする</li>
<li>チェックするセルに含まれるピクセルを全てスキャンする</li>
<li>ピクセルが一様(Homogeneous)であればそのセルを葉ノードとする</li>
<li>ピクセルが非一様(Heterogeneous)であればそのセルを四分割したノードとし、4つの子ノードをチェック対象とする</li>
<li>2.に戻る</li>
</ol>
<h2></h2><h1>
 四分木メッシュの動的更新</h1>
<p>四分木の構築は比較的低コストなので、毎フレーム行うこともできます。<br>これによって動的な障害物を回避するようなグローバルな経路探索も可能になります。<sup><a rel="noopener noreferrer">[1]</a></sup></p>
<p>まず、セルの取りうる状態を、占有と非占有の二通りだけではなく、動的な障害物がある場合も状態に加えます。<br>swarm-rs では下記のような列挙型にしています。</p>
<div><pre><code><span>#[derive(Debug, Clone, Copy, PartialEq, Eq)]</span>
<span>pub</span> <span>enum</span> <span>CellState</span> <span>{</span>
    <span>Obstacle</span><span>,</span>
    <span>Occupied</span><span>(</span><span>usize</span><span>)</span><span>,</span>
    <span>Free</span><span>,</span>
    <span>Mixed</span><span>,</span>
<span>}</span>
</code></pre></div><p><code>Occupied(usize)</code> がエージェントが占有しているセルの状態です。ペイロードの <code>usize</code> はエージェントの id を示しています。これは経路探索で自分自身でブロックされてしまうのを回避するためです。</p>
<p><code>Mixed</code> はノードが混ざった状態ピクセルを持ち、子ノードを持つ(非葉ノードである)ということを示します。</p>
<p>下の図では、緑の正方形は空いている葉で、赤い正方形は静的な障害物で占有された葉で、紫は動的な障害物(エージェント)で占有された葉です。<br>それぞれのエージェントは別々の経路を取る傾向が見て取れると思います。<br>これはお互いを障害物として経路探索から除外しているからです。</p>
<p><img src="https://user-images.githubusercontent.com/2798715/214132497-8cad42db-3a47-43c8-8651-a36cfb30e030.png" alt="image"></p>
<p>実はランダム木ベースの動的障害物回避も試したのですが、計算コストが高くなる傾向にあり、結局は四分木を使うことにしました。<br>特に swarm-rs では多数のエージェントをシミュレートしますので、ランダム木のようにエージェントごとに探索グラフの再構築を行うアルゴリズムはうまくスケールしません。<br>四分木はグローバルな探索グラフなので、エージェント間で再利用ができ、フレーム内で一度更新するだけで済みます。</p>
<h2></h2><h1>
 変更のあったセルの効率的な更新</h1>
<p>さらに大きなマップに対応するために、最適化をもっと進めることを考えます。</p>
<p>占有グリッドのほとんどのピクセルは変化しません。<br>エージェントがいるセルだけが変化します。<br>従って、変化があった部分だけを更新するようにアルゴリズムを最適化すれば、さらに高速になると考えられます。</p>
<p>まず、準備するのは2つのキャッシュマップです。<br>キャッシュマップとは、占有グリッドと同じ大きさを持つ2次元配列で、要素は前に述べた <code>CellState</code> です。<br>一つ目のキャッシュマップは現在のマップの状態を表し、二つ目のキャッシュマップは一つ前のマップの状態を表します。<br>これはコード中では次のような構造体で <code>map</code> および <code>prev_map</code> としてモデル化されています。</p>
<div><pre><code><span>pub</span> <span>struct</span> <span>CacheMap</span> <span>{</span>
    <span>/// An internal map having the size (2 ^ toplevel) ^ 2, indicating index into [`cache_buf`]</span>
    map<span>:</span> <span>Vec</span><span>&lt;</span><span>u32</span><span>&gt;</span><span>,</span>
    <span>/// An array of actual values in [`cache_map`], extracted to reduce the pixel size.</span>
    buf<span>:</span> <span>Vec</span><span>&lt;</span><span>CellState</span><span>&gt;</span><span>,</span>
    topbit<span>:</span> <span>usize</span><span>,</span>
    size<span>:</span> <span>usize</span><span>,</span>
    <span>/// A history of recently updated cells for visualization</span>
    <span>pub</span> fresh_cells<span>:</span> <span>HashMap</span><span>&lt;</span><span>[</span><span>i32</span><span>;</span> <span>2</span><span>]</span><span>,</span> <span>usize</span><span>&gt;</span><span>,</span>
    prev_map<span>:</span> <span>Option</span><span>&lt;</span><span>Vec</span><span>&lt;</span><span>u32</span><span>&gt;&gt;</span><span>,</span>
<span>}</span>
</code></pre></div><p>ちょっとした最適化を施してあり、キャッシュマップは <code>CellState</code> そのものの二次元配列ではなく、 <code>buf: Vec&lt;CellState&gt;</code> へのインデックスを <code>u32</code> で表しています。これは <code>CellState</code> のサイズは 64bit コンピュータでは 16 バイトと大きくなりがちなので、大きな配列を避けるための indirection です。 <sup><a rel="noopener noreferrer">[2]</a></sup><br>例えば、 512 x 512 ピクセルのマップでは、 16 バイトの要素の配列は 4MB になります。<br>u32 であれば要素は 4 バイトなので 1MB で済みます。<br>エージェントの id が 42億を超えるような値にならない限りは、オーバーフローの心配もないでしょう。<br>メモリ上のマップのサイズを抑えることで、 CPU のキャッシュのヒット率を上げることを期待しています。</p>
<p>さて、差分の検出には、単純に現在のキャッシュマップと前のキャッシュマップを比較して、違いを見つけるということをします。<br>このためには全てのピクセルを比較しながらスキャンしないといけないので、マップのピクセル数に比例した計算量ですが<sup><a rel="noopener noreferrer">[3]</a></sup>、四分木の更新は次に述べるアルゴリズムで変更のあった部分だけに絞られます。</p>
<ol>
<li>現在のキャッシュマップにエージェントの位置を反映した状態ラベルを書き込む</li>
<li>前のキャッシュマップと現在のそれを比較し、違いのあるピクセルを更新対象とする</li>
<li>更新対象となるピクセルを四分木から見つける</li>
<li>四分木の葉がピクセルではない場合、再帰的に分割してピクセル単位になるまで細分化する</li>
<li>ピクセルを新しいラベルに置き換える</li>
<li>置き換えた結果、親のノードが一様になるかどうかを確かめる</li>
<li>一様であればノードをマージして親ノードのみにする</li>
<li>
<ol start="6">
<li>から繰り返す</li>
</ol>
</li>
</ol>
<p>次の GIF アニメでは、四分木が動的に更新されていく様子を示しています。<br>緑や赤で一瞬光るセルが変化のあったセルで、それを含むノードのみが再計算されています。<br>計算速度は、私の環境では 1ms ぐらいから 0.05ms ぐらいまで高速化されました。</p>
<p><img src="https://user-images.githubusercontent.com/2798715/215271788-8b86b979-75f0-477f-9179-00ac40510bc1.gif" alt="swarm-rs5"></p>

<span>脚注</span>
<ol>
<li>
<p>多くの実装では障害物回避はローカルな経路探索にすると思います。動的障害物は普通はエージェントの近くにあるので、全経路の再計算までは必要ないことがほとんどです。しかし、ここでは実装の単純化を目的にグローバルな経路探索で動的障害物回避までしてしまいます。ローカルな障害物回避についてはそのうち別記事にするかもしれません。 <a rel="noopener noreferrer">↩︎</a></p>
</li>
<li>
<p><code>CellState</code> が 16 バイトも使うというのは、ちょっと納得いきがたいところはありますが、<code>Occupied(usize)</code> というバリアントを持つことから、 usize が 64bit コンピュータでは 8 バイトであることと、識別フラグが 1 バイトであってもアラインメントで 8 の倍数に引き上げられてしまうことによります。 <a rel="noopener noreferrer">↩︎</a></p>
</li>
<li>
<p>四分木のデータ構造から違いを検出することも原理的にはできると思いますが、ここでは実装のシンプルさを優先して2つのフラットなキャッシュマップの比較を行います。また、フラットなマップの比較は CPU にとっては非常に分岐予測を利かせやすく、四分木の構築のようにランダムにメモリを飛び回るのに比べて極めて速いと考えられます。 <a rel="noopener noreferrer">↩︎</a></p>
</li>
</ol>

</div></div>